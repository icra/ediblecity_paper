---
title: "ediblecity: an R package to model and estimate the benefits of urban agriculture"
author:
- Josep Pueyo-Ros \textsuperscript{1,2,*}
- Joaquim Comas \textsuperscript{1,3}
- Lluís Corominas \textsuperscript{1,2}
output: 
  pdf_document:
    number_sections: true
    keep_tex: true
    
bibliography: library.bib
---

1.  Catalan Institute for Water Research
2.  University of Girona
3.  LEQUIA, University of Girona

 \* [jpueyo\@icra.cat](mailto:jpueyo@icra.cat){.email}

```{r setup, include=FALSE}

# # This project uses {renv} for reproducibility. To install all dependencies in the proper version:
# renv::restore()

knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
library(dplyr)
library(ediblecity)
library(knitr)
library(sf)
library(purrr)
library(tidyr)
library(patchwork)
library(citr)

set.seed(1121)

options(digits = 2)

refs <- c(
"Table" = 0,
"Figure" = 0,
"Code snippet" = 0  
)

cross_refs <- list()

ref <- function(ref, label = "null"){
  if(!(ref %in% names(refs))) rlang::abort(paste(ref, "is not in refs"))
  refs[[ref]] <<- refs[[ref]] + 1
  cross_refs[[label]] <<- paste(ref, refs[[ref]])
  paste(ref, refs[[ref]])
}

```

## Abstract {.unnumbered}

Urban agriculture is gaining attraction to become one of the pillars of the urban ecological transition and to increase food security in an urbanized planet. However, there is a lack of systematic quantification of the benefits provided by urban agriculture solutions. In this paper, we present an R package to estimate several indicators related to benefits of urban agriculture. The goal is to provide a tool for researchers and practitioners interested in the impacts of urban agriculture. The ediblecity package provides functions to calculate 8 indicators: urban heat island, runoff prevention, green areas accessibility, NO~2~ sequestration, jobs created in commercial gardens, volunteers involved in community gardens, green per capita and, finally, food production. Moreover, the package also provides a function to generate scenarios with different implementations of urban agriculture. We illustrate the use of the package by comparing three scenarios in a neighborhood of Girona (Spain), which is included in the package as an example dataset. There, we compare scenarios with an increasing amount of urban agriculture solutions. The `ediblecity` package is open-source software. This allows other R developers to contribute to the package providing new functionalities or improving the existing ones.

**Keywords:** edible city solutions; urban farming; urban food; nature-based solutions; Rstats; urban challenges; societal challenges; urban agriculture

# Introduction

Urban agriculture is becoming one of the pillars of the urban ecological transition [@Saumel2019]. Likewise, urban agriculture might have a key role ensuring food security in an urbanized planet [@Barthel2015]. As a consequence, some research has paid attention on the actual or potential food production of urban agriculture [@Grafius2020; @Richardson2016]. However, some others authors argued that the importance of urban agriculture does not reside in their ability to produce food but in the social benefits it provides, such as public health [@Soga2017] and social cohesion [@Saumel2019]. Moreover, other authors stated that urban agriculture can provide environmental benefits as well, such climate regulation [@Clinton2018] or water runoff prevention [@Gittleman2017].

However, there is a lack of systematic quantification of the benefits provided by urban agriculture [@LANGEMEYER2021104055]. For instance, there is no clear evidence to what extent urban agriculture could contribute to reduce the urban heat island [@Lin2015] or to a greener economy [@Saumel2019]. However, most studies have been focused on a single initiative and one benefit [@Artmann2018].

Therefore, decision-makers, who are responsible of leading the urban transitions to more sustainable and resilient cities, are orphan of evidence in how to implement urban agriculture to maximize its impact on sustainability. Yet, several studies provided some insights that can guide the implementation of urban agriculture. For instance, some models explore the rainwater harvesting potential of urban agriculture [@Gittleman2017; @Lupia2017]. Broader, @GomezVillarino2021 developed guidelines to maximize ecosystem services through urban agriculture by applying adaptive design and providing a battery of indicators. And, as expected, many models have been developed to quantify food production and food security provided by urban agriculture by simulating a myriad of scenarios with different types of urban agriculture virtually implemented such as rooftop gardens, community gardens or private citizen-led gardens [@Grafius2020; @Grewal2012; @Hsieh2017; @MacRae2010]. Yet, a transferable model (applicable to any city) to assess simultaneously several environmental and social benefits is lacking.

Hence, our goal is to provide a tool to estimate those multiple benefits of urban agriculture that help decision-makers to strategically implement urban agriculture solutions. We developed the estimations for eight indicators measuring urban agriculture benefits and a functionality to create scenarios of urban agriculture based on the proportion of elements to be transformed to urban agriculture and on which elements will be transformed. Likewise, we packed all those functionalities in an R package called `ediblecity`. In the methods, we present the interface of the package and then we illustrate the usefulness by applying the model in a neighborhood of Girona (Spain).

# Methods

## Implementation: the model under the package

All the equations and algorithms to model the benefits of urban agriculture were encapsulated in an `R` package [@RCoreTeam2022], using one function for each indicator and one function to create scenarios. The package was created using R version 4.2.1 [@RCoreTeam2022] in RStudio desktop v. 2022.07.02. The package structure was assisted by the package `devtools` [@devtools2022] following the principles in @Wickham2022. Likewise, the documentation of the functions was assisted by the package `roxygen2` [@roxygen2022]. The dependencies of the package are:

- dplyr (>= 1.0.6) [@dplyr2022]
- magrittr (>= 2.0.1) [@magrittr2022]
- sf (>=0.9) [@sf2018]
- stars (>= 0.5) [@stars2022]
- rlang (>= 1.0) [@rlang2022]

### Urban representation of the city of interest

The `ediblecity` package provides 8 functions to estimate 8 different indicators and a function to generate scenarios. It takes as a basis a spatial representation of a city (or a part of a city) as a GIS layer. This representation must have one attribute indicating the land uses of the city, such as gardens, streets, rooftops, etc. Some indicators require specific information to be included in the representation. These is explained in each indicator's section.

```{r}
color_names <- sort(unique(city_example$land_use))
colors <- c("Brown", "Lightgreen", "chartreuse4", "Grey20", 
            "Black", "chocolate2", "Yellow", "Lightblue",
            "Red", "Grey50", "Darkgreen", "Yellow"
            )
names(colors) <- color_names

theme_set(theme_classic())

city_example |> 
  ggplot()+
  geom_sf(aes(fill=land_use), color="white", linewidth = 0.1)+
  scale_fill_manual(values = colors)+
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
        axis.text = element_text(size=6))

```
\begin{center}

`r ref("Figure", "urban_representation")`: The urban representation included in the `ediblecity` package as example.

\end{center}

The package includes the representation of Sant Narcís, a neighbourhood of Girona (Spain) as an example of an urban representation (`r cross_refs[["urban_representation"]]`). This example can help the users to create the representation of their cities of interest. In the table below, a sample with one element of each type is shown. The representation is provided as an `sf` object, which is a class for spatial data in R implemented by package `sf` [@Pebesma2018]

```{r}

tribble(
  ~Column, ~Description,
  "land_use", "A category representing the urban elements",
  "land_use_verbose", "A more detailed category for the element, for example, if it is residential",
  "floors", "The number of floors of the element, 0 for non-built",
  "area", "The surface of the element",
  "flat_area", "The surface of the element that is flat (slope < 5º)",
  "edible_area", "The surface that is used to grow edible plants. Only applicable to urban agriculture solutions"
) |> 
  kable(caption = "Structure of the urban representation example")

```

Along with the example for an urban representation, the `ediblecity` package also includes a `data.frame` with the default attributes of each green typology in the urban representation used to estimate the indicators (Table 2). This includes types of urban agriculture along with other types of green infrastructure. However, the user can provide their own attributes to estimate any indicator. In `city_land_uses` there are other columns not shown in table 2, they are logical variables (i.e. TRUE/FALSE) used internally by the package to select urban agriculture elements.

`pGreen` is the proportion of green of the urban element. In urban agriculture solutions, this is overriden by the attribute `edible_area`. The following attributes come in pairs (min, max) to consider uncertainty in the estimations. The functions use a random value within the range provided by the pair of values for each element in the city. `no2_seq` is the capacity of the element to capture NO~2~ in gr/s. `food` is the food productivity in kg/m^2^ and `CN` is their curve number, used to calculate infiltration rates. The details are provided in following sections.

```{r}

city_land_uses |>
  select(-starts_with("...")) |> 
  select(-edible, -public, -jobs, -volunteers, -location) |>
  select(-starts_with("water")) |> 
  kable(caption = "General attributes of the elements of urban green used to estimate the indicators")
```
### Indicators estimated

#### Urban heat island

The urban heat island is a measure of how urban agriculture can contribute to climate change adaptation, specifically to adapt cities to the increasing heat waves [@Langemeyer2021]. The indicator uses the equation developed by @Theeuwes2017, which was validated in 14 cities. It calculates the difference in air temperature between the urban street canyon and the rural environment. To calculate this indicator, the user must provide a raster representing the sky view factor (SVF), which describes the proportion of the unobstructed hemisphere above a certain location. SAGA, a collection of open-source algorithms for geocomputation, provides an algorithm to calculate the SVF [@Conrad2008].


$$
UHI = \frac{1}{N}\sum_{i=1}^{N}{(2 - SVF_i - Fveg_i) \times \sqrt[4]{\frac{\frac{Q_ql}{C_air \times P_air} \times \Delta{T^3}}{U}}}
$$
<!-- $$ -->

where $Fveg$ is the proportion of vegetation in cell $i$; $Q_ql$ is the daily average global radiation (in W/m^2^/hour); $C_air$ is the air heat capacity (in J); $P_air$ is air density (in kg/m^3^); $\Delta{T}$ is the difference between the maximum and minimum daily average temperatures (in ºC); and $U$ is the daily average wind speed (in m/s).

The indicator to estimate the urban heat island is implemented by the package under the function `UHI`. The user must provide the urban representation (`x`) and the raster with SVF values (`SVF`). The `green_df` argument is a `data.frame` with the proportion of green of each `land_use` in the urban representation ($Fveg$ in the equation). All the meteorological arguments are provided by default, based on the example provided (Mediterranean climate). However, the user can override them to provide values of their city of interest.

The function returns by default a summary of statistics of the UHI in `x` (min, 25%, 50%, mean, 75% and max values). If the argument `return_raster` is set to `TRUE`, the function returns a raster as `stars` object [@Pebesma2021] with the UHI values. If `verbose` is set to `TRUE`, then the function returns a vector (i.e. an array) with the UHI in each cell. Both use the same resolution than `SVF`.

`r ref("Code snippet", "uhi")`: Function and arguments to estimate urban heat island.

```{r uhi_demo, echo=TRUE, eval=FALSE}

UHI(
  x,                         # Urban representation
  SVF,                       # Raster with the sky view factor
  green_df = NULL,           # Fveg in the UHI equation
  Qql = 6.11,                # Daily average global radiation
  Cair = 1007,               # Air heat capacity
  Pair = 1.14,               # Air density
  Tmax = 30.8,               # Maximum daily average temperature
  Tmin = 20,                 # Minimum daily average temperature
  windspeed = 2.77,          # Average wind speed
  return_raster = FALSE,     # Should function return a raster or numeric values?
  verbose = FALSE            # Should the function return all the values or a summary?
)

```

#### Runoff prevention

Surface runoff is the flow of water occurring on the ground surface when excess rainwater can no longer sufficiently rapidly infiltrate in the soil. Hence, runoff mitigation contributes to climate resilience since rain events will increase due to climate change [@Shukla2019]. The indicator measures the runoff in the city after a specific 24-hours rain event as well as the amount of rainwater harvested by harvesting systems. We departed from the model developed by the Soil Conservation Service (USDA), known as SCS runoff curve number method [@Cronshey1985].

$$
Q = \frac{(P - I_a)^2}{(P - I_a) + S}
$$

where $Q$ is the runoff in $mm$; $P$ is the rainfall volume in mm; $I_a$ is the initial abstraction (all losses before runoff begins); and $S$ is the potential soil moisture retention, which is a function of the curve number (which is determined by hydrologic soil group, see @Cronshey1985 for more details on the method). The SCS generalizes $I_a$ as $0.2S$, we modified this generalization to include the rainwater harvested:

$$
I_a = 0.2S + \sum_{i=1}^{N}{min\{Rh, Ws\}_i}
$$

where $Rh$ is the potential water harvested by the element $i$, calculated as the amount of water fallen on the surface of adjacent higher buildings that are not used for gardening (in litres); $Ws$ is the water storage capacity of the element $i$ in terms of tank volume (in litres). From both, the minimum is used to calculate $I_a$.

The `runoff_prev` function estimates the runoff ($Q$ in the equation) as well as the total rainfall in `x` and the total rainwater harvested in cubic meters. Along with the urban representation (`x`), the user must provide a `data.frame` (`runoff_df` argument) with four variables: land use, minimum and maximum curve numbers and a logical variable indicating if the land use (a urban garden, a building,...) has potential to harvest rainwater. The argument `rain` allows to set the rain event (in mm), which must be defined by the user. The curve number of each element is randomized within this range provided in `runoff_df`. If `runoff_df` is not provided, `city_land_uses` is used instead. Following, `floors_field` is the name of attribute in `x` that specifies the number of floors of each element; `harvest_dist` (in m) is the maximum distance to consider that a building is adjacent to the element; and `tank_size` is a range for the volume of the rainwater tank, proportional to the surface of the element (in l/m^2^). The volume of each tank in the city is randomized within this range and multiplied by the element where they are located. All randomizations follow a random uniform distribution within the correspondent range.

`r ref("Code snippet", "runoff")`: Function and arguments to estimate runoff prevention
```{r runoff_demo, eval=FALSE, echo=TRUE}

runoff_prev(
  x,                          # Urban representation
  runoff_df = NULL,           # A data.frame with land use values
  rain = 85,                  # Rain event in mm.
  floors_field = "floors",    # Variable in `x` containing the number of floors of each element
  harvest_dist = 10,          # Maximum distance to consider for rainwater harvesting surfaces
  tank_size = c(0, 45)        # Range for the size of tanks in m3
)
```

#### Green areas accessibility

This indicator calculates the distance from each home to the closest public green area and return a summary of statistics (min, 25%, 50%, mean, 75% and max). It includes the possibility to exclude areas smaller than a threshold. The function to calculate these distances is `green_distance` (code snippet 3). It requires, as usual, the urban representation (`x`) and a vector with all the categories considered public green areas. If it is not provided, the function uses the categories from `city_land_uses` where the attribute `public` is `TRUE`. The argument `residence_col` indicates the variable of the urban representation (`x`) that must be used to identify the residences. Subsequently, `residences` indicates which categories of the ones contained by the variable passed to `residence_col` must be considered.  The `min_area` argument can be used to exclude smaller areas than the value passed to the function (the threshold mentioned above).

If `percent_out` is set to `TRUE`, the function returns the percentage of houses that are further than `max_dist` argument from their closest public green area (excluding areas smaller than `min_area`). The default values for `min_area` and `max_dist` follow the recommendations of the World Health Organization, who recommended that all residences should be closer than 300 meters from a public green area larger than 0.5 ha.

Finally, if `verbose` argument is set to `TRUE`, a vector with all distances from residences to green areas (larger than `min_area`) is returned.

`r ref("Code snippet", "green")`: Function and arguments to calculate green accessibility
```{r, eval=FALSE, echo=TRUE}

green_distance(
  x,                                     # The urban representation
  green_cat = NULL,                      # The land uses considered urban green
  residence_col = "land_use_verbose",    # The variable than contains information of what is a residence
  residences = "Residence",              # The categories of former variable considered residences
  min_area = 5000,                       # Smaller areas are not included in the calculations
  percent_out = FALSE,                   # Should the function return a percentage of residences out
  max_dist = 300,                        # Which is the distaince to consider that a residence is out?
  verbose = FALSE                        # Should return a summary of distance or all values?
)

```

#### Nitrogen dioxide sequestration

Nitrogen dioxide is a good proxy of overall air quality [@Mayer1999] and one of the most concerning issues in cities, with important consequences on respiratory diseases and lung cancer [@Kampa2008]. This indicator calculates the amount of NO~2~ sequestered by urban green and urban agriculture solutions (in g/s).

$$
NO_2 seq = \sum_{i=1}^{N}\frac{{a_i \times cap_i}}{1000}
$$

where $a_i$ is the area (in m^2^) of the element $i$; and $cap_i$ is the capacity of element $i$ to sequester NO~2~ (in $\mu$g·s^-1·m^-2^).

The function to estimate the NO~2~ sequestered is `no2_seq` (code snippet 4). It has only two arguments; the urban representation (`x`) and a `data.frame` with four columns:

- `land_uses`: Column with the land use.
- `no2_seq1`: The low range of NO2 sequestration of each function (in $\mu$g·s^-1/m-^2^).
- `no2_seq2`: The high range of NO2 sequestration of each function (in $\mu$g·s^-1/m-^2^).
- `pGreen`: The proportion of green surface in each function.

When the argument is `NULL` (default), the function uses the `city_land_uses` dataset provided with the package that contains NO~2~ sequester capacity of different types of urban green.

The capacity ($cap_i$ in the previous equation) of each element is randomized within the range provided by `no2_seq1` and `no2_seq2`. As well the area of each element is multiplied by `pGreen`. In urban agriculture solutions, the attribute `edible_area` overrides the more general `pGreen`.

`r ref("Code snippet")`: Function and arguments to calculate NO~2~ sequestration
```{r no2_demo, echo=TRUE, eval=FALSE}

no2_seq(x,                 # The urban representation
        green_df = NULL)   # The data.frame with the NO2 sequestration capacity of each land use.

```

#### Jobs created and volunteers involved

When the urban agriculture solutions are community solutions they need volunteers to be involved. On the other hand, when they are for commercial purposes, they are supposed to create jobs. Therefore, two indicators are proposed to account for the hours of work in the ECS. One indicator relates to volunteers time and the other one relates to time of new workers (jobs created).  Both indicators use the same equation:

$$
jobs | volunteers = \sum_{i=1}^{N}a_i \times k
$$

where $a_i$ is the area in m^2^ used to grow plants (`edible_area`) in the element $i$; and $k$ is the number of jobs or volunteers by m^2^. In both functions, $k$ is sampled from a random uniform distribution within the specified range. Then, a Monte Carlo simulation of 1,000 iterations is executed to estimate the confidence interval. The default values were based on two sources, an empirical study [@CoDyre2015] and the [FoodMetres project](http://www.foodmetres-kp.eu).

The functions to calculate these indicators are `edible_jobs` and `edible_volunteers` respectively (code snippet 5). They share the same arguments, expect for `jobs` and `volunteers`, which is the value of $k$ in the previous equation. As usual, the first argument is the urban representation (`x`), `edible` is the land uses in `x` that are urban agriculture solutions (if `NULL`, `city_land_uses` is used as default), the attribute of `x` defining the area used to grow plants is `area_col`, the confidence interval is defined in `interval`, and if `verbose` is set to `TRUE`, instead of the confidence interval, the function returns a vector of length 1,000 with all the results of the Monte Carlo simulation.

`r ref("Code snippet")`: Function and arguments to calculate number of jobs created and volunteers involved in urban agriculture.

```{r, echo=TRUE, eval=FALSE}

edible_jobs(
  x,                              # The urban representation
  jobs = c(0.000163, 0.022),      # The k parameter
  edible = NULL,                  # The land uses that are urban agriculture
  area_col = "edible_area",       # The variable containing the surface dedicated to grow plants
  interval = 0.95,                # The confidence interval returned by the function
  verbose = FALSE                 # Should return all values or a summary?
)

edible_volunteers(
  x,                              # The urban representation
  volunteers = c(0.00163, 0.22),  # The k parameter
  edible = NULL,                  # The land uses that are urban agriculture
  area_col = "edible_area",       # The variable containing the surface dedicated to grow plants
  interval = 0.95,                # The confidence interval returned by the function
  verbose = FALSE                 # Should return all values or a summary? 
)

```


#### Green per capita

We propose an indicator to estimate green per capita at neighborhood level and at city level, including public and private gardens to account for environmental justice [@Kabisch2014c]. At the neighborhood level a ratio between the most and least green neighborhoods is calculated, thus higher values meaning a major difference between neighborhoods and less spatial justice. Moreover, since wealthier areas tend to have more private gardens [@Farahani2018], these can be included in the account of green per capita to not underestimate green per capita in those neighborhoods.

The function to calculate this indicator is `green_capita` (code snippet 6). Along with the urban representation (`x`). As in other functions, the `green_categories` argument in the function is a list of the categories to be considered as green areas. To calculate the green per capita in the overall city, the user must provide the number of inhabitants in `inhabitants`. At a city level, the function returns the average amount of green per capita in the city (in m^2^/inhabitant). Likewise there are two options to calculate green per capita at a neighbourhood level. The urban representation can contain two variables indicating the name of the neighbourhood and the inhabitants (specified in `name_col` and `inh_col` arguments respectively). Or the user can provide a GIS layer with the neighbourhoods' boundaries and their attributes.

Furthermore, when the `private` argument is set to `TRUE`, the private gardens are also considered. Alternatively, the user can provide a list of elements to be considered as private green areas (e.g. parks, urban gardens,...). When the argument `verbose` is set to `TRUE`, the function returns the green per capita in each neighbourhood instead of the ratio between the most and least green ones. Finally, the argument `min_inh` is to exclude neighbourhoods whose number of inhabitants is under a threshold to avoid the bias in green per capita due to unpopulated neighbourhoods (e.g. industrial districts).

`r ref("Code snippet")`: Function and arguments to calculate green per capita.

```{r, echo=TRUE, eval=FALSE}

green_capita(
  x,                        # The urban representation
  green_categories = NULL,  # The categories considered as urban green
  inhabitants = NULL,       # The number of inhabitants in the city
  neighbourhoods = NULL,    # The spatial representation of neighborhoods
  name_col = NULL,          # The variable that contains de name of the neighborhoods
  inh_col = NULL,           # The variable that contains the inhabitants of the neighborhoods
  private = FALSE,          # Should private green be considered?
  verbose = FALSE,          # Should return all the information or just the ratio?
  min_inh = 0               # Neighborhoods with less hanbitants are excluded
)

```

#### Food production

Although many authors stated that the main goal of urban agriculture is not to produce food [@Saumel2019; @Tornaghi2012c], food production is undoubtedly an important component of urban gardens [@Furness2018; @Steel2008] and the most frequent output modeled at a city scale [@Grafius2020; @Grewal2012]. The food production is measured in terms of productivity (kg/m^2^):

$$
Food \; production = \sum_{i=1}^{N}y_k a_i
$$

where $y_k$ is the yield (in $kg/m^2$) of the category $k$ of urban garden; and $a_i$ is the area of urban garden $i$ in $m^2$. By default, the value of $y$ is randomized using a random uniform distribution within the range defined by `food1` and `food2` values in `city_land_uses`, which are the minimum and maximum yield values found in literature for each category of urban garden. The function computes a Monte Carlo simulation of 1000 iterations to calculate the confidence interval.

The function that calculates the food production is `food_production` (code snippet 7). It takes the urban representation (`x`) as the first argument. If the second argument `edible_df` is `NULL`, the function uses the values from `city_land_uses` as specified above. Otherwise, the user can provide its own values as a `data.frame` with three columns: 

- `land_uses`: specifying the category of urban agriculture, it should match the categories from `x`.
- `food1` and `food2` specifies the range of the random uniform distribution to randomize yield.

The argument `area_col` points to the variable of `x` that determines the area dedicated to grow plants in each urban garden. If `NULL`, the total area of each element is used instead. The number passed to `interval` defines which confidence interval of the food production must be returned by the function. However, if `verbose` is set to `TRUE`, the function returns a vector of length 1,000 with the results of each iteration of the Monte Carlo simulation. 

`r ref("Code snippet")`: Function and arguments to estimate food production

```{r, echo=TRUE, eval=FALSE}

food_production(
  x,                        # The urban representation
  edible_df = NULL,         # Dataframe containing information on yields
  area_col = "edible_area", # Variable of x with surface
  interval = 0.95,          # Confidence interval returned by the function
  verbose = FALSE           # Should return all the values or just the confidence interval?
)

```

### Scenarios of urban agriculture

The `ediblecity` package also provides the user with a function to create new scenarios based on the urban representation and a predefined set of urban agriculture solutions (Table 3) based on where they are located (private gardens, plots on ground or rooftops) and their purpose (private, community or commercial). The function returns a spatial representation of the new scenario (`sf` object) with the same structure of the urban representation.

```{r}

tibble(
  `Urban agriculture solutions` = city_land_uses$land_uses[1:5],
  Location = c("Private gardens", rep("Plots on ground", 2), rep("Rooftops", 2)),
  Purpose = c("Private", rep("Community", 2), rep("Commercial", 2))
) |> 
  kable(caption = "Elements created in new scenarios")

```
The location of new urban agriculture elements is randomized among all locations that fulfill the requirements of minimum area for that element. However, this is not the case for commercial gardens, they are settled in the larger available locations, assuming that commercial initiatives have the power to acquire the best spots.

The function to create a new scenario is called `set_scenario` (code snippet 8). It requires many arguments but most of them have default values to facilitate its use. The function needs the urban representation (`x`). Then three arguments (`pGardens`, `pVacant`, `pRooftop`) control the proportion of new elements that must be created. The next three arguments (`edible_area_*`) control the proportion of the area of the new elements that is dedicated to grow plants (`edible_area`). The `edible_area` of each new elements is randomized within the range provided in the arguments. The next trio of arguments (`min_area_*`) specify the minimal area required to create new elements. If there are not enough elements largen than `min_area_*` to fulfill the first arguments, a message is displayed to inform the user (unless `quiet` argument is set to `TRUE`). Another three arguments (`*_from`) control which elements can be converted from the urban representation to create new urban agriculture solutions. The argument `pcommercial` controls the percentage of plots on ground and rooftop that should have commercial purposes instead of community. This does not affect private gardens since they are assumed to be for personal use. Finally, `area_field` specifies which attribute of `x` must be used as the area of the elements. By default, it is am attribute called `flat_area` that measures the area with an slope lower than 5º (in `city_example`).

`r ref("Code snippet")`: Function and arguments to create new scenarios.

```{r, echo=TRUE, eval=FALSE}

set_scenario(
  x,                                       # The urban representation
  pGardens = 1,                            # Proportion of private edible gardens
  pVacant = 1,                             # Proportion of vacant plots converted to gardens on ground
  pRooftop = 1,                            # Proportion of rooftops converted to rooftop gardens
  edible_area_garden = c(0.02, 0.3),       # Proportion of surface dedicated to grow plants in private gardens
  edible_area_vacant = c(0.52, 0.75),      # And in gardens on ground
  edible_area_rooftop = c(0.6, 0.62),      # And in rooftop gardens
  min_area_garden = 10,                    # Exclude smaller private gardens
  min_area_vacant = 100,                   # Exclude smaller vacant plots
  min_area_rooftop = 100,                  # Exclude smaller rooftops
  private_gardens_from = "Normal garden",  # Land uses to be converted to private edible gardens
  vacant_from = "Vacant",                  # Land uses to be converted to gardens on ground
  rooftop_from = "Rooftop",                # Land uses to be converted to rooftop gardens
  pCommercial = 0,                         # Proportion of commercial gardens vs community gardens
  area_field = "flat_area",                # Variable of x containing available surface in each element
  quiet = FALSE                            # Should the function raise warnings?
)

```

## Operation

The `ediblecity` package is compatible with versions of R higher than 2.10. Although, it was created using version 4.2.1. `r ref("Code snippet", "install")` shows how to install the last development version, available in [r-universe](https://r-universe.dev/search/).

`r cross_refs[["install"]]`: Code to install the last development version of the package

```{r, eval=FALSE, echo=TRUE}

# install.packages("devtools") # if not yet installed
install.packages("ediblecity", repos = "jospueyo.r-universe.dev")

```

Once the package is installed, it works as any R package. It can be attached to the namespace using `library(ediblecity)` or preceding the functions with `ediblecity::`. To check the documentation of the package and its functions, type `help(package="ediblecity")` in the R console.

## Limitations

As all abstraction of the reality, the equations and algorithms of the `ediblecity` package present some limitations. One limitation is the use of GIS layers to create scenarios and estimate indicators, which is intrinsically in two dimensions, and sometimes 2.5 dimensions, since we consider the height of buildings. This prevents to consider other urban agriculture solutions that are relevant such as vertical farming. To consider vertical solutions, the `ediblecity package` should include 3D calculations.

Another limitation is the subset of indicators chosen, this is, as we said, a choice. Other indicators might be chosen instead or added to the current subset. Hopefully, the `ediblecity` package will be well received by the community of R scientists and other developers will add new indicators to fulfill their own needs. Indeed, this is one of the main advantages of open-source software.

# Use cases

## Create scenarios of urban agriculture

To our understanding, the most important use case of the `ediblecity` package is to compare scenarios. To illustrate this, we created two scenarios and compare them with the original `city_example`. The package has been designed to work well with the `tidyverse` framework in `R` [@Wickham2019], especially, with the `map_*` family in the `purrr` package [@Henry2022]. Therefore, we first create the two scenarios and save them in a list along with the original urban representation, which we called `s0` (`r ref("Code snippet", "use_set_scenario")`). The scenario `s1` will convert the 25% of elements to urban agriculture solutions while the scenario `s2` will convert the 100%. Half of gardens in vacant plots, streets and rooftop will have commercial purposes.


```{r, include=FALSE}

opts_chunk$set(echo = TRUE, collapse = TRUE, comment = "#>")

```


`r cross_refs[["use_set_scenario"]]`: Code to create the scenarios.

```{r}

# Create new scenarios
scenarios <- map(c(0.25, 1), ~set_scenario(city_example, 
                             pGardens = .x,
                             pVacant = .x,
                             pRooftop = .x,
                             private_gardens_from = "Normal garden",
                             vacant_from = c("Vacant", "Streets"),
                             rooftop_from = "Rooftop",
                             pCommercial = 0.5))

# Add city_example as s0
scenarios[[3]] <- city_example

# Name the scenarios
names(scenarios) <- c("s1", "s2", "s0")
scenarios <- scenarios[order(names(scenarios))]
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}

counting <- function(x, .name){
  x |> 
    st_drop_geometry() |> 
    filter(land_use %in% city_land_uses$land_uses[1:5]) |> 
    group_by(land_use) |> 
    summarize(!!sym(paste(.name, "n")) := n(),
              !!sym(paste(.name, "area")) := sum(area))
}

counting(scenarios[[1]], "s0") |> 
  full_join(counting(scenarios[[2]], "s1")) |> 
  full_join(counting(scenarios[[3]], "s2")) |> 
  mutate(across(where(is.numeric), ~if_else(is.na(.x), 0L, .x))) |> 
  relocate(land_use, ends_with("n"), ends_with("area")) |> 
  kable(caption = "Number of agriculture solutions in each scenario and their surfaces (in squared meters)")
```

## Calculate indicators and compare scenarios

In this section, we calculate the indicators for each scenario and create tables or plots as illustration of how the results can be used.

`r ref("Code snippet")`: Code to create a table with the result of urban heat island in all three scenarios.

```{r, warning=FALSE, message=FALSE}

# We use the SVF object that is provided for the city_example in the package
map_dfr(scenarios, UHI, SVF = ediblecity::SVF, .id = "Scenario") |> 
  kable(caption = "Summary statistics of urban heat island effect in each scenario (in ºC)")

```

As expected the second scenario (`s2`) has the lowest values for urban heat island, but no too far from the scenario `s1`. Both present a reduction of approximated 50% in average urban heat island regarding the base scenario. We can also generate a raster with the urban heat island for each scenario, like in `r ref("Figure", "UHI_plots")`

```{r, include=FALSE, eval = FALSE}

map(scenarios, ~ UHI(.x, SVF = ediblecity::SVF, return_raster = TRUE), .id = "Scenarios") |>
  map(~ ggplot()+
        stars::geom_stars(data = .x, na.action = na.omit)+
        coord_equal()+
        scale_fill_distiller(palette = "RdYlBu")+
        theme_void()+
        theme(plot.title = element_text(hjust=0.5))
      ) |>
  map2(names(scenarios), ~ .x+labs(title = .y)) |>
  wrap_plots()+plot_layout(guides = 'auto', nrow = 1)

ggsave("assets/UHI_plots.png")

```

![](assets/UHI_plots.png)
`r cross_refs[["UHI_plots"]]`: Raster returned by the `UHI` function when `return_raster` is set to `TRUE`.

`r ref("Code snippet", "runoff_table")`: Code to calculate the runoff prevention in each scenario.

```{r}

map_dfr(scenarios, runoff_prev, .id="scenario") |> 
  kable(caption = "Runoff (mm), total rainfall (m^3^) and rainwater harvested in each scenario (m^3^)")

```

The total rainfall presented the same value in all scenarios because we use the same rain event and all scenarios represent the same total area. Moreover, although there is an important reduction of runoff and an increase in rainwater harvested regarding the base scenario, there is no improvement from scenario 1 to scenario 2. As shown in `r cross_refs[["runoff_table"]]`, the rainwater harvested is larger in scenario 1. This is explained because the algorithm uses as catchment areas all adjacent upper areas that are not used for urban agriculture. Hence, as rooftop converted to urban agriculture increases, the availability of catchment areas decrease. The infiltration rates also increase because rooftop gardens retain water but this is not enough to compensate the reduction in harvesting.

`r ref("Code snippet")`: Code to generate a boxplot of distances to public green areas.

```{r, fig.height=3}

map_dfc(scenarios, green_distance, min_area = 100, verbose = TRUE) |> 
  pivot_longer(everything()) |> 
  ggplot(aes(x=name, y=as.numeric(value), fill=name))+
  geom_boxplot(show.legend = FALSE)+
  labs(fill="Scenario", x= "Scenario", y="Distance from residences \nto public green areas (m)")

```

`r ref("Figure")`: Comparison among scenarios of the distances to each residences to its closest public green area

`r ref("Code snippet")`: Estimation of NO~2~ sequestration in all three scenarios

```{r}

map_dfr(scenarios, no2_seq, .id="Scenario") |> 
  kable(caption = "Sequestration of nitrogen dioxide in each scenario")
```

Regarding the capacity to absorb NO~2~, we see a significant improvement from base scenario to scenario 1 but not as larger from scenario 1 to scenario 2.

In the `r ref("Code snippet", "use_jobs")`, there is an example in job to calculate jobs as well as volunteers in the different scenarios.

`r cross_refs[["use_jobs"]]`: Code to estimate jobs and volunteers in each scenario.

```{r, fig.height=3}

jobs <- scenarios |> 
  map_dfc(edible_jobs, verbose = TRUE) |> 
  pivot_longer(everything(), values_to = "Jobs")

volunteers <- scenarios |> 
  map_dfc(edible_volunteers, verbose = TRUE) |>
  pivot_longer(everything(), values_to = "Volunteers")

bind_cols(jobs, volunteers["Volunteers"]) |> 
  pivot_longer(-name, names_to = "Indicator") |> 
  ggplot(aes(x=Indicator, y=value, fill=name))+
  geom_boxplot()+
  labs(y = "People", fill="Scenario")

```
`r ref("Figure")`: Comparison of jobs created and volunteers involved in each scenario.

As expected, the base scenario presented very low values, it creates 0 jobs since there is not any commercial garden and a median of `r edible_volunteers(scenarios[[1]])[[2]]` volunteers, involved in one community garden. The number of jobs and volunteers also increases from scenario 1 to scenario 2 as well as the uncertainty related to the numbers.

Below, we calculate the green per capita in each neighborhoods. To do so, we use another spatial data set provided by the `ediblecity` package (`neighbourhoods_example`) which contains the neighborhoods of `city_example` along with the inhabitants in each neighborhood.

`r ref("Code snippet")`: Code to calculate the green per capita in each neighborhood 

```{r, fig.height=3}

scenarios |> 
  map_dfr(green_capita, 
          neighbourhoods = neighbourhoods_example, 
          inh_col = "inhabitants",
          name_col = "name",
          private = TRUE,
          verbose = TRUE,
          .id = "scenarios") |> 
  ggplot(aes(x=name, y=green_capita, fill=scenarios))+
  geom_col(position = position_dodge(), color = "black")+
  labs(x="Neighborhoods", y=bquote(m^2/person), fill="Scenario")

```
`r ref("Figure")`: Comparison of green per capita in both neighbourhoods of Sant Narcís.

The difference between both neighborhoods is due to their urban origin. Sant Narcís nord was designed like a city garden while Sant Narcís sud is mainly composed of apartments. The interesting issue is that the improvement across scenarios is larger in Sant Narcís nord that in Sant Narcís sud, evidencing that an increase in urban agriculture is not enough to achieve environmental justice unless it is ideologically planned [@Jennings2012].

The last, but not least, indicator provided by the `ediblecity` package is the food production. The food production is assumed as higher in gardens for commercial purposes than in community gardens, which the goal is not to maximize the production. This is especially the case of rooftops, since the commercial rooftop gardens are assumed to use hydroponic technology while community rooftop gardens are assumed to use raised beds following the study of @Caputo2020.

`r ref("Code snippet")`: Code to get confidence intervals of food production in Tm/year.

```{r}

scenarios |> 
  map_dfr(food_production, .id = "Scenario") |> 
  mutate(across(where(is.numeric), ~ .x/1000)) |> 
  kable(caption = "Food production in Tm/year in each scenario")

```

Although the median are clearly different, we cannot state that food production is bigger in scenario 2 than in scenario 1 with a 95% of confidence (i.e. p-value > 0.05 in differences between `s1` and `s2`). Taking the most optimistic scenario (`s2` at quantile 95%) and considering the value per capita, the urban agriculture in our example could produce `r prod = food_production(scenarios[[3]])[[3]]/sum(neighbourhoods_example$inhabitants); prod` kg/year/person. The daily intake of fruits and vegetables recommended by FAO is 200 gr/person, i.e. 73 kg/person/year [@FAO2004]. Therefore, our optimistic estimation would provide `r prod/73` times the neighborhood's needs in fruits and vegetables. However, it would require (taking also the higher interval) `r jobs = edible_jobs(scenarios[[3]])[[3]];round(jobs)` people working in commercial gardens and `r vol = edible_volunteers(scenarios[[3]])[[3]];round(vol)` volunteers involved in community gardens, which is `r (jobs + vol)/sum(neighbourhoods_example$inhabitants)` times the inhabitants of the neighborhood.

## Disclaimer

Since the scenarios and the indicators have some stochastic parameters, the ideal procedure would be to integrate the creation of the scenarios and the estimation of indicators in a Monte Carlo simulation to get the confidence intervals for each combination of scenario and indicator. However, we rather kept things simple to better illustrate how to use the functions provided by the package.


# Conclusions

In this paper, we presented the `ediblecity` package: An R package to to model and estimate the benefits of urban agriculture. The package is ready to be used by R users with a basic level. It can be used to estimate the benefits of real cases as well as to simulate scenarios. In both cases, 8 indicators are calculated. In the example illustrated in this paper, the uncertainty is captured using stochastic parameters. Moreover, the users are able to provide their own ranges in case they have more accurate data for the case study at stake. With more accurate data, the uncertainty can be easily reduced changing the arguments of the functions. Likewise, some assumptions of the models can be override with truly statements.

The `ediblecity` package is open-source software under MIT license. This allows other R developers to contribute to the package providing new functionalities or improving the existing ones. Therefore, an open-source software is always a work-in-progress.

## Data Availability statement {.unnumbered}

All data underlying the results are available as part of the `ediblecity` package and no additional source data are required.

## Software availability {.unnumbered}

- The `ediblecity` package is available at [https://github.com/icra/ediblecity](https://github.com/icra/ediblecity) under MIT license.
- This paper has been entirely written using RMarkdown, the code to reproduce the paper is available at [https://github.com/icra/ediblecity_paper](https://github.com/icra/ediblecity_paper) under MIT license.

## Authors contributions {.unnumbered}

**JPR**, **JC** and **LC** contributed to conceptualization, methodology and writing - review & editing. **JPR** contributed to data curation, formal analysis, software, validation, visualization and writing - original draft preparation. **JC** and **LC** contributed to funding acquisition, project administration, resources and supervision.

## Competing interests {.unnumbered}

No competing interests were disclosed.

## Grant information {.unnumbered}

Authors acknowledge the support from the European Union Horizon 2020 innovation & action project EdiCitNet (GA776665), the Economy and Knowledge Department of the Catalan Government through Consolidated Research Groups ICRA tech (2021-SGR-01283) and LEQUIA (2021-SGR-01352), and the CERCA program. Also, we acknowledge GiroNat the support from Gironat project, by *Fundación Biodiversidad of Ministerio para la Transición Ecológica y el Reto Demográfico (MITECO)* in the frame of  *Plan  de  Recuperación,  Transformación  y  Resiliencia  (PRTR)*,  funded by European Union - NextGeneration.


## Acknowledgements {.unnumbered}

We want to aknowledge the `R` community for being so supportive and friendly in StackOverflow, but also in Mastodon under the hashtag #Rstats. Also, to Posit (former Rstudio) for all the tools that make the life easier to R developers. Likewise, we want to thank all R developers that altruistically spend their time in building open-source packages.

# References {.unnumbered}
