---
title: "ediblecity: an R package to model and estimate the benefits of urban agriculture"
author:
- Josep Pueyo-Ros \textsuperscript{1,2,*}
- Joaquim Comas \textsuperscript{1,3}
- Lluís Corominas \textsuperscript{1,2}
output: 
  pdf_document:
    number_sections: true
    keep_tex: true
bibliography: library.bib
---

1.  Catalan Institute for Water Research
2.  University of Girona
3.  LEQUIA, University of Girona

 \* [jpueyo\@icra.cat](mailto:jpueyo@icra.cat){.email}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
library(dplyr)
library(ediblecity)
library(knitr)
library(sf)
library(purrr)
library(tidyr)

set.seed(1121)

options(digits = 2)

refs <- c(
"Table" = 0,
"Figure" = 0,
"Code snippet" = 0  
)

cross_refs <- list()

ref <- function(ref, label = "null"){
  if(!(ref %in% names(refs))) rlang::abort(paste(ref, "is not in refs"))
  refs[[ref]] <<- refs[[ref]] + 1
  cross_refs[[label]] <<- paste(ref, refs[[ref]])
  paste(ref, refs[[ref]])
}



```

## Abstract {.unnumbered}

# Introduction

Urban agriculture is gaining attraction as one of the pillars of the urban ecological transition [@Saumel2019]. Likewise, urban agriculture might have a key role ensuring food security in an urbanized planet [@Barthel2015]. As a consequence, some research has paid attention on the actual or potential food production of urban agriculture [@Grafius2020; @Richardson2016]. However, some others authors argued that the importance of urban agriculture does not reside in their ability to produce food but in the social benefits it provides, such as public health [@Soga2017] and social cohesion [@Saumel2019]. Moreover, other authors stated that urban agriculture can provide environmental benefits as well, such climate regulation [@Clinton2018] or water runoff prevention [@Gittleman2017].

However, there is a lack of systematic quantification of the benefits provided by urban agriculture [@LANGEMEYER2021104055]. For instance, there is no clear evidence to what extent urban agriculture could contribute to reduce the urban heat island [@Lin2015] or to a greener economy [@Saumel2019]. However, most studies have been focused on a single initiative and one benefit [@Artmann2018].

Therefore, decision-makers, who are responsible of leading the urban transitions to more sustainable and resilient cities, are orphan of evidence in how to implement urban agriculture to maximize its impact on sustainability. Yet, several studies provided some insights that can guide the implementation of urban agriculture. For instance, some models assist planners in rainwater harvesting [@Gittleman2017; @Lupia2017]. Broader, @Gomez-Villarino2021 developed guidelines to maximize ecosystem services through urban agriculture. And, as expected, many models have been developed to quantify food production and food security provided by urban agriculture [@Grafius2020; @Grewal2012; @Hsieh2017; @MacRae2010].

Hence, our goal is to provide a model to estimate multiple benefits of urban agriculture that help decision-makers to strategically implement urban agriculture solutions. We developed the estimations for eight indicators and a functionality to create scenarios of urban agriculture based on the proportion of elements to be transformed to urban agriculture and on which elements will be transformed. In the methods, we present the main functionalities of the `ediblecity` package and then we apply those to an example in a neighborhood of Girona (Spain).

# Methods

## Urban representation of the city of interest

The `ediblecity` package provide 8 functions to estimate 8 different indicators and a function to create scenarios. It takes as a basis a spatial representation of a city (or a part of a city) as a GIS layer. This representation must have one attribute indicating the land uses of the city (aka functions), such as gardens, streets, rooftops, etc. Some indicators require specific information to be included in the representation. These is explained in each indicator's section.

```{r}
color_names <- sort(unique(city_example$Function))
colors <- c("Brown", "Lightgreen", "chartreuse4", "Grey20", 
            "Black", "chocolate2", "Yellow", "Lightblue",
            "Red", "Grey50", "Darkgreen", "Yellow"
            )
names(colors) <- color_names

theme_set(theme_classic())

city_example |> 
  ggplot()+
  geom_sf(aes(fill=Function), color="white", linewidth = 0.1)+
  scale_fill_manual(values = colors)+
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
        axis.text = element_text(size=6))

```

`r ref("Figure", "urban_representation")`: The urban representation included in the `ediblecity` package as example.


The package includes the representation of Sant Narcís, a neighbourhood of Girona (Spain) as an example of an urban representation (`r cross_refs[["urban_representation"]]`). This example can help the users to create the representation of their cities of interest. In the table below, a sample with one element of each type is shown. The representation is provided as an `sf` object, which is a class for spatial data in R implemented by package `sf` [@Pebesma2018]

`r ref("Table", "structure")`: Structure of the urban representation example"

```{r}
tribble(
  ~Column, ~Description,
  "Function", "A category representing the urban elements",
  "Function_verbose", "A more detailed category for the element, for example, if it is residential",
  "floors", "The number of floors of the element, 0 for non-built",
  "area", "The surface of the element",
  "flat_area", "The surface of the element that is flat (slope < 5º)",
  "edible_area", "The surface that is used to grow edible plants. Only applicable to urban agriculture solutions"
) |> 
  kable()

```

Along with the example for a urban representation, the `ediblecity` package also includes a `data.frame` with the general attributes of each green typology in the urban representation used to estimate the indicators (`r ref("Table", "city_functions")`). However, the user can provide their own attributes to estimate any indicator. In `city_functions` there are other columns not shown in table `r cross_refs[["city_functions"]]`, they are logical variables (i.e. TRUE/FALSE) used internally by the package to select urban agriculture elements.

`pGreen` is the proportion of green of the urban element. In urban agriculture solutions, this is overriden by the attribute `edible_area`. The following attributes come in pairs. This is to consider uncertainty in the estimations. The functions use a random value within the range provided by the pair of values for each element in the city. `no2_seq` is the capacity of the element to capture NO~2~ in gr/s. `food` is the food productivity in kg/m^2^ and `CN` is their curve number, used to calculate infiltration rates [@Cronshey1985].

`r cross_refs[["city_functions"]]`: General attributes of the elements of urban green used to estimate the indicators.

```{r}

city_functions |>
  select(-starts_with("...")) |> 
  select(-edible, -public, -jobs, -volunteers, -location) |>
  select(-starts_with("water")) |> 
  kable()
```
## Indicators estimated

### Urban heat island

The urban heat island is a measure of how urban agriculture can contribute to climate change adaptation [@Langemeyer2021]. The indicator follows the equation developed by @Theeuwes2017, which was validated in 14 cities. It calculates the difference in air temperature between the urban street canyon and the rural environment. To calculate this indicator, the user must provide a raster representing the sky view factor (SVF). SAGA, a collection of open-source algorithms for geocomputation, provides an algorithm to calculate this [@Conrad2008].

\begin{align}
UHI = \frac{1}{N}\sum_{i=1}^{N}{(2 - SVF_i - Fveg_i) \times \sqrt[4]{\frac{\frac{Q_ql}{C_air \times P_air} \times \Delta{T^3}}{U}}}
\end{align}

where $Fveg$ is the percentage of vegetation in cell $i$; $Q_ql$ is the daily average global radiation; $C_air$ is the air heat capacity; $P_air$ is air density; $\Delta{T}$ is the difference between the maximum and minimum daily average temperatures; and $U$ is the daily average wind speed.

The indicator to estimate the urban heat island is implemented by the package under the function `UHI`. The user must provide the urban representation (`x`) and the raster with SVF values (`SVF`). The `green_df` argument is a `data.frame` with the proportion of green of each `Function` in the urban representation. All the meteorological arguments are provided by default, based on the example provided (Mediterranean climate). However, the user can override them to provide values of their city of interest.

The function returns by default a summary of statistics of the UHI in `x`. If the argument `return_raster` is set to `TRUE`, the function returns a raster as `stars` object [@Pebesma2021] with the UHI values. If `verbose` is set to `TRUE`, then the function returns a vector (i.e. an array) with the UHI in each cell. Both use the same resolution than `SVF`.

`r ref("Code snippet", "uhi")`: Function and arguments to estimate urban heat island.

```{r uhi_demo, echo=TRUE, eval=FALSE}

UHI(
  x,
  SVF,
  green_df = NULL,
  Qql = 6.11,
  Cair = 1007,
  Pair = 1.14,
  Tmax = 30.8,
  Tmin = 20,
  windspeed = 2.77,
  return_raster = FALSE,
  verbose = FALSE
)

```

### Runoff prevention

Surface runoff is the flow of water occurring on the ground surface when excess rainwater can no longer sufficiently rapidly infiltrate in the soil. Hence, runoff mitigation contributes to climate resilience since rain events will increase due to climate change [@Shukla2019]. The indicator measures the runoff in the city after a specific 24-hours rain event as well as the amount of rainwater harvested by harvesting systems. We departed from the model developed by the Soil Conservation Service (USDA), known as SCS runoff curve number method [@Cronshey1985].

\begin{align}
Q = \frac{(P - I_a)^2}{(P - I_a) + S}
\end{align}

where $P$ is the rainfall volume in mm; $I_a$ is the initial abstraction (all losses before runoff begins); and $S$ is the potential soil moisture retention, which is a function of the curve number. The SCS generalizes $I_a$ as $0.2SS$, we modified this generalization to include the rainwater harvested:

\begin{align}
I_a = 0.2S + \sum_{i=1}^{N}{min\{Rh, Ws\}_i}
\end{align}

where $Rh$ is the potnetial water harvested by the element $i$, calculated as the amount of water fallen on the surface of adjacent higher buildings that are not used for gardening (in litres); $Ws$ is the water storage capacity of the element $i$ in terms of tank volume (imn litres). From both, the minimum is used to calculate $I_a$.

The `runoff_prev` function estimates the runoff as well as the total rainfall in `x` and the total rainwater harvested. Along with the urban representation (`x`), the user must provide a `data.frame` with the functions, two columns representing the range of curve numbers and a logical column indicating if the element has potential to harvest rainwater. The argument `rain` allows to set the rain event (in mm). The curve number of each element is randomized within this range. If `runoff_df` is not provided, `city_functions` is used instead. Following, `floors_field` is the name of attribute in `x` that specifies the number of floors of each element; `harvest_dist` is the maximum distance to consider that a building is adjacent to the element; and `tank_size` is a range for the volume of the rainwater tank (in m^3^). The volume of each tank in the city is randomized within this range.

`r ref("Code snippet", "runoff")`: Function and arguments to estimate runoff prevention
```{r runoff_demo, eval=FALSE, echo=TRUE}

runoff_prev(
  x,
  runoff_df = NULL,
  rain = 85,
  floors_field = "floors",
  harvest_dist = 10,
  tank_size = c(0, 45)
)
```

### Green areas accessibility

This indicator calculates the distance from each home to the closest public green area and return a summary of statistics. It includes the possibility to exclude areas smaller than a threshold. The function to calculate these distances is `green_distance`. It requires, as usual, the urban representation (`x`) and a vector with all the categories considered public green areas. If it is not provided, the function uses the categories from `city_functions` where the attribute `public` is `TRUE`. The argument `residence_col` indicates the function which attribute of `x` must be used to identify the residences. Subsequently, `residences` indicates which categories of `residence_col` must be considered.  The `min_area` argument can be used to exclude smaller areas than the value passed to the function.

If `percent_out` is set to `TRUE`, the function return the percentage of houses that are further than `max_dist` argument from their closest public green area (excluding areas smaller than `min_area`). The default values for `min_area` and `max_dist` follow the recommendations of the World Health Organization, who recommended that all residences should be closer than 300 meters from a public green area larger than 0.5 ha.

Finally, if `verbose` argument is set to `TRUE`, a vector with all distances is returned.

`r ref("Code snippet", "green")`: Function and arguments to calculate green accessibility
```{r, eval=FALSE, echo=TRUE}

green_distance(
  x,
  green_cat = NULL,
  residence_col = "Function_verbose",
  residences = "Residence",
  min_area = 5000,
  percent_out = FALSE,
  max_dist = 300,
  verbose = FALSE
)

```

### Nitrogen dioxide sequestration

Nitrogen dioxide is a good advisor of overall air quality [@Mayer1999] and one of the most concerning issues in cities, with important consequences on respiratory diseases and lung cancer [@Kampa2008]. This indicator calculates the amount of NO~2~ sequestered by urban green and urban agriculture solutions (in g/s).

\begin{align}
seq = \sum_{i=1}^{N}{a_i \times cap_i} \times 1000
\end{align}

where $a_i$ is the area (in m^2^) of the element $i$; and $cap_i$ is the capacity of element $i$ to sequester NO~2~ (in $\mu$g/s).

The function to estimate the NO~2~ sequestered is `no2_seq`. It has only two arguments. The urban representation (`x`) and a `data.frame` with four columns:

- `functions`: Column with the function to be considered in the calculations corresponding
 to `Function` attribute in `x`.
- `no2_seq1`: The low range of NO2 sequestration of each function (in $\mu$g/s/m^2^).
- `no2_seq2`: The high range of NO2 sequestration of each function (in $\mu$g/s/m^2^).
- `pGreen`: The proportion of green surface in each function.


The capacity ($cap_i$ in the previous equation) of each element is randomized within the range provided by `no2_seq1` and `no2_seq2`. As well the area of each element is multiplied by `pGreen`. In urban agriculture solutions, the attribute `edible_area` overrides the more general `pGreen`.

`r ref("Code snippet")`: Function and arguments to calculate NO~2~ sequestration
```{r no2_demo, echo=TRUE, eval=FALSE}

no2_seq(x, green_df = NULL)

```

### Jobs created and volunteers involved

There are two indicators that are closely related. They regard to hours of work. When the urban agriculture solutions are community solutions they need volunteers to be involved. On the other hand, when they are for commercial purposes, they are supposed to create jobs. Both indicators used the same equation:

\begin{align}
jobs | volunteers = \sum_{i=1}^{N}a_i \times k
\end{align}

where $a_i$ is the area in m^2^ used to grow plants (`edible_area`) in the element $i$; and $k$ is the number of jobs or volunteers by m^2^. In both functions, $k$ is randomized within a range and a Monte Carlo simulation of 1,000 iterations is executed to estimate the confidence interval.

The functions to calculate these indicators are `edible_jobs` and `volunteer_jobs` respectively. They share the same arguments, expect for `jobs` and `volunteers`, which is the value of $k$ in the previous equation. As usual, the first argument is the urban representation (`x`), the attribute of `x` defining the area used to grow plants is `are_col`, the confidence interval is defined in `interval`, and if `verbose` is set to `TRUE`, instead of the confidence interval, the function return a vector of length 1,000 with all the results of the Monte Carlo simulation.

`r ref("Code snippet")`: Function and arguments to calculate number of jobs created and volunteers involved in urban agriculture.

```{r, echo=TRUE, eval=FALSE}

edible_jobs(
  x,
  jobs = c(0.000163, 0.022),
  edible = NULL,
  area_col = "edible_area",
  interval = 0.95,
  verbose = FALSE
)

edible_volunteers(
  x,
  volunteers = c(0.00163, 0.22),
  edible = NULL,
  area_col = "edible_area",
  interval = 0.95,
  verbose = FALSE
)

```


### Green per capita

With this indicator, we had the goal to go beyond a simple account of green per capita and consider also some ingredients of environmental justice [@Kabisch2014c]. Therefore, the indicator is able to measure the green per capita at neighbourhood level (if neighbourhoods are provided) and it has a shorthand to calculate the ratio between the most and least green neighbourhoods. Moreover, since wealthier areas tend to have more private gardens [@Farahani2018], these can be included in the account of green per capita to not understimate green per capita in those neighbourhoods.

The function to calculate this indicator is `green_capita`. Along with the urban representation (`x`). As in other functions, `green_categories` is a list of the categories to consider as green areas. To calculate the green per capita in the overall city, the user must provide the number of inhabitants in `inhabitants`. There are two options to calculate green per capita at a neighbourhood level. The urban representation can contain two columns indicating the neighbourhoods and the inhabitants on that, passed to `name_col` and `inh_col` respectively. Or the user can provide a layer with the neighbourhoods boundaries with the previous attributes indicated in the same arguments as previous.

Furthermore, when the `private` argument is set to `TRUE`, the private gardens are also considered. Alternatively, the user can provide a list of elements to be considered as private green areas. When the argument `verbose` is set to `TRUE`, the function returns the green per capita in each neighbourhoods instead of the ratio between the most and least green ones. Finally, the argument `min_inh` is to exclude neighbourhoods whose number of inhabitants is under a threshold to avoid the bias in green per capita due to unpopulated neighbourhoods (e.g. industrial districts).

`r ref("Code snippet")`: Function and arguments to calculate green per capita.

```{r, echo=TRUE, eval=FALSE}

green_capita(
  x,
  green_categories = NULL,
  inhabitants = NULL,
  neighbourhoods = NULL,
  name_col = NULL,
  inh_col = NULL,
  private = FALSE,
  verbose = FALSE,
  min_inh = 0
)

```

### Food production

Although many authors stated that the main goal of urban agriculture is not to produce food [@Saumel2019; @Tornaghi2012c], food production is undoubtedly and important component of urban gardens [@Furness2018; @Steel2008] and the most frequent output modeled at a city scale [@Grafius2020; @Grewal2012]. The food production is measured in terms of productivity:

\begin{align}
Food \; production = \sum_{i=1}^{N} \times y_k \times a_i
\end{align}

where $y_k$ is the yield (in $kg/m^2$) of the category $k$ of urban garden; and $a_i$ is the area of urban garden $i$ in $m^2$. By default, the value of $y$ is randomized using the range defined by `food1` and `food2` columns in `city_functions`. The function computes a Monte Carlo simulation of 1000 iterations to calculate the confidence interval.

The function that calculates the food production is `food_production`. It takes the urban representation (`x`) as the first argument. If the second argument `edible_df` is `NULL`, the function uses the values from `city_functions` as specified above. Otherwise, the user can provide its own values as a `data.frame` with three columns: 
- `functions`: specifying the category of urban agriculture, it should match the categories from `x`.
- `food1` and `food2` specifies the range within the yield is randomized.

The argument `area_col` indicates which attribute of `x` determines the area dedicated to grow plants in each element. If `NULL`, the total area of each element is used instead. The number passed to `interval` defines which confidence must be returned by the function. However, if `verbose` is set to `TRUE`, the function returns a vector of length 1,000 with the results of each iteration of the Monte Carlo simulation. 

`r ref("Code snippet")`: Function and arguments to estimate food production

```{r, echo=TRUE, eval=FALSE}

food_production(
  x,
  edible_df = NULL,
  area_col = "edible_area",
  interval = 0.95,
  verbose = FALSE
)

```

## Scenarios of urban agriculture

The `ediblecity` package also provides the user with a function to create new scenarios based on the urban representation and a predefined set of urban agriculture solutions (`r ref("Table", "scenarios")`) based on where they are located (private gardens, plots on ground or rooftops) and their purpose (private, community or commercial). The function returns a spatial representation of the new scenario (`sf` object) with the same structure of the urban representation.

`r cross_refs[["scenarios"]]`: Elements created in new scenarios.

```{r}

tibble(
  `Urban agriculture solutions` = city_functions$functions[1:5],
  Location = c("Private gardens", rep("Plots on ground", 2), rep("Rooftops", 2)),
  Purpose = c("Private", rep("Community", 2), rep("Commercial", 2))
) |> 
  kable()

```
The location of new urban agriculture elements is randomized among all locations that fulfill the requirements of minimum area for that element. However, this is not the case for commercial gardens, they are settled in the larger available locations, assuming that commercial initiatives have the power to acquire the best spots.

The function to create a new scenario is called `set_scenario`. It requires many arguments but most of them have default values to facilitate its use. The function needs the urban representation (`x`). Then three arguments (`pGardens`, `pVacant`, `pRooftop`) control the proportion of new elements that must be created. The next three arguments (`edible_area_*`) control the proportion of the area of the new elements that is dedicated to grow plants (`edible_area`). The `edible_area` of each new elements is randomized within the range provided in the arguments. The next trio of arguments (`min_area_*`) specify the minimal area required to create new elements. If there are not enough elements largen than `min_area_*` to fulfill the first arguments, a message is displayed to inform the user (unless `quiet` argument is set to `TRUE`. Another three arguments (`*_from`) control which elements can be converted from the urban representation to create new urban agriculture solutions. The argument `pcommercial` controls the percentage of plots on ground and rooftop that should have commercial purposes instead of community. This does not affect private gardens since they are assumed to be for personal use. Finally, `area_field` specifies which attribute of `x` must be used as the area of the elements. By default, it is am attribute called `flat_area` that measures the area with an slope lower than 5º (in `city_example`).

`r ref("Code snippet")`: Function and arguments to create new scenarios.

```{r, echo=TRUE, eval=FALSE}

set_scenario(
  x,
  pGardens = 1,
  pVacant = 1,
  pRooftop = 1,
  edible_area_garden = c(0.02, 0.3),
  edible_area_vacant = c(0.52, 0.75),
  edible_area_rooftop = c(0.6, 0.62),
  min_area_garden = 10,
  min_area_vacant = 100,
  min_area_rooftop = 100,
  private_gardens_from = "Normal garden",
  vacant_from = "Vacant",
  rooftop_from = "Rooftop",
  pCommercial = 0,
  area_field = "flat_area",
  quiet = FALSE
)

```

# Use cases

To our understanding, the most important use case of the `ediblecity` package is to compare scenarios. To illustrate this, we will create two scenarios and compare them with the original `city_example`. The package has been designed to work well with the `tidyverse` framework in `R` [@Wickham2019], especially, with the `map_*` family in the `purrr` package [@Henry2022]. Therefore, we first create the two scenarios and save them in a list along with the original urban representation, which we called `s0` (`r ref("Code snippet", "use_set_scenario")`). The scenario `s1` will convert the 50% of elements to urban agriculture solutions while the scenario `s2` will convert the 100%. Half of gardens in vacant plots, streets and rooftop will have commercial purposes.

```{r, include=FALSE}

opts_chunk$set(echo = TRUE, collapse = TRUE, comment = "#>")

```


`r cross_refs[["use_set_scenario"]]`: Code to create the scenarios.

```{r}

# Create new scenarios
scenarios <- map(c(0.5, 1), ~set_scenario(city_example, 
                             pGardens = .x,
                             pVacant = .x,
                             pRooftop = .x,
                             private_gardens_from = "Normal garden",
                             vacant_from = c("Vacant", "Streets"),
                             rooftop_from = "Rooftop",
                             pCommercial = 0.5))

# Add city_example as s0
scenarios[[3]] <- city_example

# Name the scenarios
names(scenarios) <- c("s1", "s2", "s0")
```

`r ref("Table", "count_scenarios")` shows the number of agriculture solutions in each scenario.

```{r, echo=FALSE, warning=FALSE, message=FALSE}

counting <- function(x, .name){
  x |> 
    st_drop_geometry() |> 
    filter(Function %in% city_functions$functions[1:5]) |> 
    count(Function, name = .name)
}

counting(scenarios[[3]], "s0") |> 
  full_join(counting(scenarios[[1]], "s1")) |> 
  full_join(counting(scenarios[[2]], "s2")) |> 
  mutate(across(where(is.numeric), ~if_else(is.na(.x), 0L, .x))) |> 
  kable()
```

## Calculate indicators and compare scenarios

In this section, we will calculate the indicators for each scenario and create tables or plots as illustration of how the results can be used.

`r ref("Code snippet")`: Code to create a table with the result of urban heat island in all three scenarios.

```{r, warning=FALSE, message=FALSE}

# We use the SVF object that is provided for the city_example in the package
map_dfr(scenarios, UHI, SVF = ediblecity::SVF) |> 
  mutate(Scenario = names(scenarios), .before = 1) |> 
  kable()

```

As expected the second scenario (`s2`) has the lowest values for urban heat island, but no too far from the scenario `s1`. Both present a reduction of approximated 50% in urban heat island regarding the base scenario.

`r ref("Code snippet")`: Code to calculte the runoff prevention in each scenario.

```{r}

map_dfr(scenarios, runoff_prev) |> 
  mutate(scenario = names(scenarios), .before = 1) |> 
  kable()

```

The total rainfall presented the same value in all scenarios because we use the same rain event and all scenarios represent the same total area. As urban agriculture becomes more present, the amount of rainwater harvested increases. However, runoff is not clearly influenced by urban agriculture because other green elements presents equal or even larger infiltration rates [@Clinton2018].

`r ref("Code snippet")`: Code to generate a boxplot of distances to public green areas.

```{r}

map_dfc(scenarios, green_distance, min_area = 100, verbose = TRUE) |> 
  pivot_longer(everything()) |> 
  ggplot(aes(x=name, y=as.numeric(value), fill=name))+
  geom_boxplot(show.legend = FALSE)+
  labs(fill="Scenario", x= "Scenario", y="Distance from residences to public green areas")

```

`r ref("Figure")`: Comparison among scenarios of the distances to each residences to its closest public green area





# Conclusion

# References {.unnumbered}
